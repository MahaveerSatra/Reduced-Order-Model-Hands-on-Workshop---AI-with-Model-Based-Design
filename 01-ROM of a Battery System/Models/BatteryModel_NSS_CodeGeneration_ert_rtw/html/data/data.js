var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"BatteryModel_NSS_CodeGeneration","ref":false,"files":[{"name":"Executor.hpp","type":"header","group":"main","path":"C:\\Mahaveer\\Examples\\AI with MBD_ROM_ Hands on Workshop\\01-ROM of a Battery System\\Models\\BatteryModel_NSS_CodeGeneration_ert_rtw","tag":"","groupDisplay":"Main file","code":"#pragma once\n\n#include <iostream>\n#include <vector>\n#include <csignal>\n#include <atomic>\n#include <algorithm>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <memory>\n\n#include \"WorkerPool.hpp\"\n#include \"Timer.hpp\"\n\nnamespace platform {\nnamespace runtime {\n\n/** @brief A global flag to control the termination of executor\n */\nvolatile std::sig_atomic_t haltExecutor = false;\n\n/** @brief The signal handler which is invoked to terminate the executor when\n *        a SIGINT or SIGTERM signal occurs\n *\n *  @param The signal number\n*/\nvoid terminationHandler(int signalNum) {\n    if(signalNum == SIGINT || signalNum == SIGTERM) {\n        // Consider aborting the program directly to avoid the synchronization problem\n        haltExecutor = true;\n    }\n}\n\n/** @brief An executor monitors events given by users and dispatches the handlers of triggered events\n *          to threads for execution. Currently the supported types of events are periodic and aperiodic.\n *\n *  Usage:\n *     platform::runtime::Executor executor;\n *\n *     executor.addEvent([](){ std::this_thread::sleep_for(std::chrono::seconds(5)); },\n *                        [](){ std::cout << \"Event B is triggered\" << std::endl; });\n *\n *     executor.addPeriodicEvent([](){ std::cout << \"Event A (period=2 ticks) is triggered\\n\" << std::endl; }, 2);\n *\n *     executor.run();\n*/\nclass Executor {\n\n    private:\n        /** @brief A logger using standard output streams\n         *\n         *  Default logger type which is used as the logger template parameter in the `run()` methods\n         *  when users do not provide a logger. For example, when logging is not needed.\n         */\n        struct DefaultLogger {\n            std::ostream& LogVerbose() { return std::cout; }\n            std::ostream& LogError()   { return std::cerr; }\n        };\n\n\n    public:\n\n        Executor(uint32_t numWorkers=0U) : workerPool(numWorkers) { }\n\n        ~Executor() {\n            stop();\n        }\n\n        Executor(const Executor& other) = delete;\n        Executor(Executor&& other) = delete;\n\n        Executor& operator = (const Executor& other) = delete;\n        Executor& operator = (Executor&& other) = delete;\n\n        /** @brief Function for adding a periodic event.\n         *\n         *  @param handler The event handler which gets called when the event is triggered\n         *  @param tick The period of the event\n         *  @param offset The time shift relative to the period\n        */\n        void addPeriodicEvent(std::function<void()>&& handler, const size_t tick, const size_t offset=0) {\n            periodicEvents.push_back(std::unique_ptr<PeriodicEvent>(\n                        new PeriodicEvent(tick, std::move(handler), offset)));\n        }\n\n        /** @brief Function for adding an aperiodic event.\n         *\n         *  @param waitFun The event to be monitored\n         *  @param handler The event handler which gets called when the event is triggered\n         *  @param haltFun The function to enable the waiting thread to return early from the waitFun\n        */\n        void addEvent(std::function<bool()>&& waitFun, std::function<void()> &&handler,\n                std::function<void()> &&haltFun) {\n            aperiodicEvents.push_back(std::unique_ptr<AperiodicEvent>(\n                        new AperiodicEvent(std::move(waitFun), std::move(handler), std::move(haltFun))));\n        }\n\n        /** @brief Set up the base rate of timer. This is only used for periodic events.\n         *\n         *  A base rate is the time unit (in seconds) of a tick. For example, if baseRate = 2 seconds,\n         *  then one tick is 2 seconds. A periodic event uses ticks to represent the length\n         *  of its period,\n         *\n         *  Example:\n         *    Assume baseRate = 2 seconds, then a periodic event with 3 ticks means this\n         *    event will repeatedly trigger every 6 seconds (3 ticks * baseRate)\n         *\n         *  @param rate The base rate in seconds\n        */\n        void setBaseRateInSeconds(std::chrono::duration<double> rate) {\n            assert(rate.count() > 0.0);\n            baseRate = rate;\n        }\n\n        /** @brief Run with a stop condition.\n         *\n         *  @param condition A callable to decide if the execution should stop\n        */\n        void run(std::function<bool()>&& condition) {\n            run<std::function<bool()>, DefaultLogger>(condition, nullptr, -1);\n        }\n\n        /** @brief Run with a stop condition passed in the current tick.\n         *\n         *  @param condition A callable passed in the current tick to decide if the execution should stop\n        */\n        void run(std::function<bool(size_t)>&& condition) {\n            run<std::function<bool(size_t)>, DefaultLogger>(condition, nullptr, -1);\n        }\n\n        /** @brief Run with a stop condition and a logger.\n         *  Example:\n         *     CustomLogger logger;\n         *     int counter = 0;\n         *\n         *     // Run with a stop condition and a logger.\n         *     executor.run([&counter](){ return counter ++ > 10; }, logger);\n         *\n         *\n         *  @param condition A callable that checks if the execution should stop (return true)\n         *  @param logger A user-provided logger\n        */\n        template <typename LoggerT>\n        void run(std::function<bool()>&& condition, LoggerT& logger) {\n            run(condition, &logger, -1);\n        }\n\n        /** @brief Run with a stop condition passed in the current tick and a logger.\n         *\n         *  Example:\n         *     CustomLogger logger;\n         *     int counter = 0;\n         *\n         *     // Run with a stop condition checking current tick, and a logger\n         *     executor.run([&counter](size_t currentTick){\n         *         return (counter ++ > 10) || currentTick > 10;\n         *      }, logger);\n         *\n         *  @param condition A callable passed in the current tick (size_t) to decide if the execution should stop\n         *  @param logger A user-provided logger\n        */\n        template <typename LoggerT>\n        void run(std::function<bool(size_t)>&& condition, LoggerT& logger) {\n            run(condition, &logger, -1);\n        }\n\n        /** @brief Run with a logger and an optional time limit (default is -1 which means infinite)\n         *\n         *  @param logger A user-provided logger\n         *  @param tickLimit Total number of ticks allowed for the execution\n        */\n        template <typename LoggerT>\n        void run(LoggerT& logger, int tickLimit=-1) {\n            auto fcn = [] { return false; };\n            run(fcn, &logger, tickLimit);\n        }\n\n\n        /** @brief Run without an optional time limit (default is -1 which means infinite)\n         *\n         *  Example:\n         *      executor.run();\n         *\n         *  @param tickLimit Total number of ticks allowed for the execution\n         */\n        void run(int tickLimit=-1) {\n            auto fcn = [] { return false; };\n            run<decltype(fcn), DefaultLogger>(fcn, nullptr, tickLimit);\n        }\n\n    private:\n\n        /** @brief The event base class - each event (regardless of the type) must have a handler\n         *\n         *  The executor guarantees:\n         *    1. The handler will be invoked as many times as the event gets triggered.\n         *    2. The handler will be invoked sequentially even the event gets triggered\n         *       multiple times in a short period.\n         *\n         *  Users need to guarantee:\n         *     There is no data race between concurrent events and handlers.\n         */\n        struct Event {\n            Event(std::function<void()> &&handler): handler(std::move(handler)) {}\n\n            std::function<void()> handler;\n\n            /** @brief remainRuns records the number of times the handler needs to be executed\n             *\n             *  Whenever the event gets triggered, remainRuns is incremented by 1\n             *  and the remainRuns is decremented by 1 every time after the handler is executed.\n             *  This can be used for overrun detection.\n             */\n            std::atomic<int> remainRuns {0};\n\n            void operator()() {\n               auto numRuns = remainRuns.load();\n               while(numRuns) {\n                   for(int i=0; i<numRuns; i++) {\n                       handler();\n                   }\n                   const int numFinishedRuns = numRuns;\n                   numRuns = remainRuns.fetch_sub(numFinishedRuns) - numFinishedRuns;\n               }\n            }\n        };\n\n        struct PeriodicEvent final: public Event {\n            PeriodicEvent(size_t tick, std::function<void()> &&handler, size_t offset):\n                Event(std::move(handler)), tick(tick), offset(offset) {}\n            size_t tick {1};\n            size_t offset {0};\n        };\n\n        /** @brief Aperiodic events are triggered irregularly\n         *\n         *  An aperiodic event might never be triggered or triggered after a long time, and thus\n         *  a haltFun is required to allow the thread waiting for the aperiodic event to return\n         *  early when the executor terminates.\n         */\n        struct AperiodicEvent final: public Event {\n            AperiodicEvent(std::function<bool()> &&event, std::function<void()> &&handler, std::function<void()> &&haltFun):\n                Event(std::move(handler)), waitFun(std::move(event)), haltFun(std::move(haltFun)) {}\n            std::function<bool()> waitFun;\n            std::function<void()> haltFun;\n        };\n\n\n        std::vector<std::unique_ptr<PeriodicEvent>> periodicEvents;\n        std::vector<std::unique_ptr<AperiodicEvent>> aperiodicEvents;\n\n        std::vector<std::thread> waiters;\n        utility::WorkerPool workerPool;\n\n        bool start {false};\n        std::chrono::duration<double> baseRate {0.0};\n\n        std::condition_variable cv;\n        std::mutex mtx;\n\n        /** @brief The function to be called by the threads monitoring aperiodic events\n         *\n         *  The function executed by the threads which wait for aperiodic events.\n         *  Executor creates a thread (called waiter) to wait for each aperiodic event. The waiter\n         *  will call the `waitFun` which returns when the aperiodic event is triggered.\n         *  The `index` is the index of the aperiodic event in the vector.\n         *\n         *  @param index The index of the aperiodic event monitored by the thread\n        */\n        void waiterLoop(const size_t index);\n\n\n        /** @brief Schedule periodic events if any\n         *\n         *  Create a timer armed with the base rate to schedule the periodic events and dispatch\n         *  the handlers of triggered events to execution. This function is called by the main\n         *  thread only when periodic events exist.\n         *\n         *  @param logger An optional logger which will be called to emit information\n         *  @param tickLimit An optional time limit\n        */\n        template <typename LoggerT, typename CallableT>\n        void schedulePeriodicEvents(LoggerT* logger, int tickLimit=-1, CallableT& condition = nullptr);\n\n        /** @brief Register the SIGINT and SIGTERM signal handler which will terminate the executor when called\n         */\n        void registerTerminationHandler() {\n            std::signal(SIGINT, terminationHandler);\n            std::signal(SIGTERM, terminationHandler);\n        }\n\n        /** @brief Invoke the halt function to enable early return from aperiodic events\n         *\n         *  Notify waiters to return from waitFun. Without this, waiters might get stuck indefinitely\n         */\n        void unblockWaiters() {\n            std::for_each(aperiodicEvents.begin(), aperiodicEvents.end(),\n                    [](std::unique_ptr<AperiodicEvent>& e){ e->haltFun(); });\n        }\n\n        /**  @brief Terminate the executor and join all threads (workers & waiters)\n         */\n        void stop();\n\n        /**  @brief Check the given condition to see executor should stop or not\n         */\n        template<typename CallableT>\n        bool shouldStop(CallableT& condition, size_t currentTick, std::false_type) {\n            return condition(currentTick);\n        }\n        template<typename CallableT>\n        bool shouldStop(CallableT& condition, size_t, std::true_type) {\n            return condition();\n        }\n\n        /** @brief This function implements the logic to schedule all events\n         *\n         *  All other run() methods will call this function to start the event execution\n         *\n         *  @param logger An optional logger which will be called to emit information\n         *  @param tickLimit An optional time limit\n         */\n        template <typename CallableT, typename LoggerT>\n        void run(CallableT& condition, LoggerT *logger=nullptr, int tickLimit=-1);\n\n        /** @brief An utility function to calculate the greatest common divisor of two numbers\n         */\n        size_t gcd(size_t a, size_t b) const { return (b == 0) ? a : gcd(b, a%b); }\n};\n\n\nvoid Executor::stop() {\n    {\n        std::lock_guard<std::mutex> lock(mtx);\n        start = false;\n        haltExecutor = true;\n    }\n    cv.notify_all();\n\n    const auto joinThread = [](std::thread& thd){\n      if(thd.joinable()) {\n          thd.join();\n      }\n    };\n\n    std::for_each(waiters.begin(), waiters.end(), joinThread);\n}\n\nvoid Executor::waiterLoop(const size_t index) {\n    std::unique_lock<std::mutex> lock(mtx);\n    cv.wait(lock, [&](){ return haltExecutor || start; });\n\n    while(start) {\n        if(haltExecutor) {\n            break;\n        }\n\n        lock.unlock();\n        const bool isTriggered = aperiodicEvents[index]->waitFun();\n        if(!isTriggered) {\n            break;\n        }\n\n        const bool isDispatched = (aperiodicEvents[index]->remainRuns.fetch_add(1) != 0);\n\n        if(!isDispatched) {\n            workerPool.post([this, index](){ (*this->aperiodicEvents[index])(); });\n        }\n        lock.lock();\n    }\n}\n\ntemplate <typename LoggerT, typename CallableT>\nvoid Executor::schedulePeriodicEvents(LoggerT *logger, int tickLimit, CallableT& condition) {\n\n    // Sort periodic events in decreasing order based on the ticks. This is for ERT\n    // rate-monotonic scheduling (short cycle events get triggered first.).\n    std::sort(periodicEvents.begin(), periodicEvents.end(),\n        [](std::unique_ptr<PeriodicEvent>& e1, std::unique_ptr<PeriodicEvent>& e2){\n            return e1->tick < e2->tick;\n        }\n    );\n\n    const size_t initValue = 1;\n    const auto lcm = std::accumulate(periodicEvents.begin(), periodicEvents.end(), initValue,\n        [this](size_t lcm, std::unique_ptr<PeriodicEvent>& event) {\n            return (lcm * event->tick) / gcd(lcm, event->tick);\n        }\n    );\n\n    utility::Timer timer(baseRate);\n\n    std::unique_lock<std::mutex> lock(mtx);\n    start = true;\n    cv.notify_all();\n\n    try {\n        timer.start();\n    }\n    catch (const std::exception& e) {\n        if(logger) {\n           logger->LogError() << \"Error: \" << e.what() << '\\n';\n        }\n        haltExecutor = true;\n        cv.notify_all();\n        return ;\n    }\n\n    size_t tickCounter = 0;\n    size_t currentTick = 0;\n    bool needLastExecution = false;\n\n    while(!haltExecutor) {\n        lock.unlock();\n\n        // Wait for timer pass one tick (period)\n        try {\n            timer.wait();\n        }\n        catch (const std::exception&) {\n            if(logger) {\n                logger->LogError() << \"Error: an error occurs in timer wait function\\n\";\n            }\n            break;\n        }\n\n        for(size_t i=0; i<periodicEvents.size(); i++) {\n            if(tickCounter % periodicEvents[i]->tick == periodicEvents[i]->offset) {\n                if(periodicEvents[i]->remainRuns.fetch_add(1) == 0) {\n                    workerPool.post([this, i](){ (*this->periodicEvents[i])(); });\n                }\n                else {\n                    // Prior executions are not finished yet while the event gets triggered again\n                    if(logger) {\n                        logger->LogVerbose() << \"INFO: Overrun detected: Periodic event \" << i << \" triggers too fast\\n\";\n                    }\n                }\n            }\n        }\n\n        tickCounter = (tickCounter+1)%lcm;\n        currentTick ++;\n\n        const bool isLastTick = (tickLimit > 0 && --tickLimit == 0);\n        using isVoidInputType = std::is_constructible<std::function<bool(void)>,\n                                                  typename std::remove_reference<CallableT>::type>;\n        if(isLastTick || shouldStop(condition, currentTick, isVoidInputType())) {\n            needLastExecution = true;\n            break;\n        }\n        lock.lock();\n    } // End of periodic event schedule loop\n\n\n    if(needLastExecution) {\n        // Dispatch all events before termination\n        for(auto &event: periodicEvents) {\n            if(event->remainRuns.fetch_add(1) == 0) {\n                workerPool.post([&event](){ (*event)(); });\n            }\n        }\n        // Wait for all events to finish execution\n        workerPool.wait();\n    }\n}\n\ntemplate <typename CallableT, typename LoggerT>\nvoid Executor::run(CallableT& condition, LoggerT* logger, int tickLimit) {\n\n    if((periodicEvents.empty() && aperiodicEvents.empty()) || tickLimit == 0) {\n        return;\n    }\n\n    workerPool.start();\n\n    for(size_t i=0; i<aperiodicEvents.size(); i++) {\n        waiters.emplace_back([this, i]{ this->waiterLoop(i); });\n    }\n\n    registerTerminationHandler();\n\n    if(!periodicEvents.empty()) {\n        schedulePeriodicEvents<LoggerT, CallableT>(logger, tickLimit, condition);\n    }\n    else {\n        // If a time limit (tickLimit) is given, wake up the main thread only\n        // when reaching the time limit. Otherwise, wake up every 1 second.\n        double sleepInterval = tickLimit > 0 ?\n            tickLimit * std::chrono::duration<double>(baseRate).count() : 1.0;\n\n        std::unique_lock<std::mutex> lock(mtx);\n        start = true;\n        cv.notify_all();\n\n        while(1) {\n            const bool predicateResult = cv.wait_for(lock,\n                    std::chrono::duration<double>(sleepInterval),\n                    [&]{ return !haltExecutor; });\n\n            // Two possible wakeup scenarios that the executor should terminate:\n            //    1. The predicate is true\n            //    2. A time limit is given and time out\n            if(predicateResult || tickLimit > 0) {\n                break;\n            }\n        }\n    }\n    unblockWaiters();\n    stop();\n}\n\n} // End of runtime namespace\n} // End of platform namespace\n\n\n"},{"name":"ert_main.cpp","type":"source","group":"main","path":"C:\\Mahaveer\\Examples\\AI with MBD_ROM_ Hands on Workshop\\01-ROM of a Battery System\\Models\\BatteryModel_NSS_CodeGeneration_ert_rtw","tag":"","groupDisplay":"Main file","code":"/* Code generated for Simulink model BatteryModel_NSS_CodeGeneration */\n/* Code generated on 29-Apr-2025 12:04:31.112 */\n#include \"Executor.hpp\"\n#include \"BatteryModel_NSS_CodeGeneration.h\"\n\nstatic BatteryModel_NSS_CodeGeneration rtObj{};\n\n/* main handles the following: */\n/*  - Instantiate the model object and owns its memory. */\n/*  - Call the model initialize and terminate functions. */\n/*  - Register tasks and add them to the scheduler */\nint main() {\n\n  /* These rate variables represent how many base rate  */\n  /* periods to wait before running a step function. */\n  double const baserate = 1;\n  /* Initialize Function */\n  rtObj.initialize();\n\n  /* Create scheduler and add tasks */\n  platform::runtime::Executor executor;\n  executor.setBaseRateInSeconds(std::chrono::duration<double>(baserate));\n  /* Add periodic tasks */\n  executor.addPeriodicEvent([]() { rtObj.step(); }, 1);\n\n/* Run model */\n#if defined(rtmSetStopRequested) && defined(rtmGetStopRequested)\n  executor.run([]() { return rtmGetStopRequested(rtObj.getRTM()); });\n#else\n  executor.run();\n#endif\n\n  /* Terminate Function */\n\n  return EXIT_SUCCESS;\n}\n"},{"name":"BatteryModel_NSS_CodeGeneration.cpp","type":"source","group":"model","path":"C:\\Mahaveer\\Examples\\AI with MBD_ROM_ Hands on Workshop\\01-ROM of a Battery System\\Models\\BatteryModel_NSS_CodeGeneration_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// File: BatteryModel_NSS_CodeGeneration.cpp\r\n//\r\n// Code generated for Simulink model 'BatteryModel_NSS_CodeGeneration'.\r\n//\r\n// Model version                  : 3.7\r\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n// C/C++ source code generated on : Tue Apr 29 12:04:26 2025\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: Intel->x86-32 (Windows32)\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n#include \"BatteryModel_NSS_CodeGeneration.h\"\r\n#include \"rtwtypes.h\"\r\n#include <cmath>\r\n\r\n//\r\n// Output and update for atomic system:\r\n//    '<S8>/act1'\r\n//    '<S8>/act2'\r\n//    '<S8>/act3'\r\n//    '<S8>/act4'\r\n//\r\nvoid BatteryModel_NSS_CodeGeneration::act1(const real_T rtu_In1[16], real_T\r\n  rty_Out1[16])\r\n{\r\n  // Trigonometry: '<S19>/Tanh'\r\n  for (int32_T i{0}; i < 16; i++) {\r\n    rty_Out1[i] = std::tanh(rtu_In1[i]);\r\n  }\r\n\r\n  // End of Trigonometry: '<S19>/Tanh'\r\n}\r\n\r\n// Model step function\r\nvoid BatteryModel_NSS_CodeGeneration::step()\r\n{\r\n  real_T rtb_Add_c[16];\r\n  real_T rtb_Tanh[16];\r\n  real_T tmp[5];\r\n  real_T rtb_Delay[2];\r\n  real_T rtb_IC;\r\n  real_T rtb_IC1;\r\n  int32_T i;\r\n  int32_T i_0;\r\n\r\n  // Outputs for Atomic SubSystem: '<Root>/Neural State Space Battery Model'\r\n  // InitialCondition: '<S1>/IC' incorporates:\r\n  //   Inport: '<Root>/SOC'\r\n\r\n  if (rtDW.IC_FirstOutputTime) {\r\n    rtDW.IC_FirstOutputTime = false;\r\n    rtb_IC = 0.3;\r\n  } else {\r\n    rtb_IC = rtU.SOC;\r\n  }\r\n\r\n  // End of InitialCondition: '<S1>/IC'\r\n\r\n  // InitialCondition: '<S1>/IC1' incorporates:\r\n  //   Inport: '<Root>/Temperature'\r\n\r\n  if (rtDW.IC1_FirstOutputTime) {\r\n    rtDW.IC1_FirstOutputTime = false;\r\n    rtb_IC1 = 280.0;\r\n  } else {\r\n    rtb_IC1 = rtU.Temperature;\r\n  }\r\n\r\n  // End of InitialCondition: '<S1>/IC1'\r\n\r\n  // Outputs for Atomic SubSystem: '<S1>/Neural State Space Model'\r\n  // Delay: '<S5>/Delay'\r\n  rtb_Delay[0] = rtDW.Delay_DSTATE[0];\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/fc1'\r\n  // Product: '<S14>/Matrix Multiply' incorporates:\r\n  //   Delay: '<S5>/Delay'\r\n\r\n  tmp[0] = rtDW.Delay_DSTATE[0];\r\n\r\n  // End of Outputs for SubSystem: '<S8>/fc1'\r\n\r\n  // Delay: '<S5>/Delay'\r\n  rtb_Delay[1] = rtDW.Delay_DSTATE[1];\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/fc1'\r\n  // Product: '<S14>/Matrix Multiply' incorporates:\r\n  //   Constant: '<S4>/Constant1'\r\n  //   Delay: '<S5>/Delay'\r\n  //   Gain: '<S4>/Gain1'\r\n  //   Inport: '<Root>/InputCurrent'\r\n  //   Sum: '<S4>/Add1'\r\n\r\n  tmp[1] = rtDW.Delay_DSTATE[1];\r\n  tmp[2] = (rtU.InputCurrent - -0.0429870499610664) * 1.8044950228454222;\r\n  tmp[3] = (rtb_IC - 0.50184304399524893) * 3.3117626614401305;\r\n  tmp[4] = (rtb_IC1 - 294.13793103448273) * 0.090533937074353241;\r\n\r\n  // Sum: '<S32>/Add' incorporates:\r\n  //   Constant: '<S14>/Bias'\r\n  //   Constant: '<S14>/Weights'\r\n  //   Product: '<S14>/Matrix Multiply'\r\n\r\n  for (i = 0; i < 16; i++) {\r\n    rtb_IC1 = 0.0;\r\n    for (i_0 = 0; i_0 < 5; i_0++) {\r\n      rtb_IC1 += rtConstP.Weights_Value_l[(i_0 << 4) + i] * tmp[i_0];\r\n    }\r\n\r\n    rtb_Add_c[i] = rtb_IC1 + rtConstP.Bias_Value_n[i];\r\n  }\r\n\r\n  // End of Sum: '<S32>/Add'\r\n  // End of Outputs for SubSystem: '<S8>/fc1'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/act1'\r\n  act1(rtb_Add_c, rtb_Tanh);\r\n\r\n  // End of Outputs for SubSystem: '<S8>/act1'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/fc2'\r\n  // Sum: '<S36>/Add' incorporates:\r\n  //   Constant: '<S15>/Bias'\r\n  //   Constant: '<S15>/Weights'\r\n  //   Product: '<S15>/Matrix Multiply'\r\n  //   Trigonometry: '<S25>/Tanh'\r\n\r\n  for (i = 0; i < 16; i++) {\r\n    rtb_IC1 = 0.0;\r\n    for (i_0 = 0; i_0 < 16; i_0++) {\r\n      rtb_IC1 += rtConstP.Weights_Value_f[(i_0 << 4) + i] * rtb_Tanh[i_0];\r\n    }\r\n\r\n    rtb_Add_c[i] = rtb_IC1 + rtConstP.Bias_Value_g[i];\r\n  }\r\n\r\n  // End of Sum: '<S36>/Add'\r\n  // End of Outputs for SubSystem: '<S8>/fc2'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/act2'\r\n  act1(rtb_Add_c, rtb_Tanh);\r\n\r\n  // End of Outputs for SubSystem: '<S8>/act2'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/fc3'\r\n  // Sum: '<S40>/Add' incorporates:\r\n  //   Constant: '<S16>/Bias'\r\n  //   Constant: '<S16>/Weights'\r\n  //   Product: '<S16>/Matrix Multiply'\r\n  //   Trigonometry: '<S25>/Tanh'\r\n\r\n  for (i = 0; i < 16; i++) {\r\n    rtb_IC1 = 0.0;\r\n    for (i_0 = 0; i_0 < 16; i_0++) {\r\n      rtb_IC1 += rtConstP.Weights_Value_i[(i_0 << 4) + i] * rtb_Tanh[i_0];\r\n    }\r\n\r\n    rtb_Add_c[i] = rtb_IC1 + rtConstP.Bias_Value_m[i];\r\n  }\r\n\r\n  // End of Sum: '<S40>/Add'\r\n  // End of Outputs for SubSystem: '<S8>/fc3'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/act3'\r\n  act1(rtb_Add_c, rtb_Tanh);\r\n\r\n  // End of Outputs for SubSystem: '<S8>/act3'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/fc4'\r\n  // Sum: '<S44>/Add' incorporates:\r\n  //   Constant: '<S17>/Bias'\r\n  //   Constant: '<S17>/Weights'\r\n  //   Product: '<S17>/Matrix Multiply'\r\n  //   Trigonometry: '<S25>/Tanh'\r\n\r\n  for (i = 0; i < 16; i++) {\r\n    rtb_IC1 = 0.0;\r\n    for (i_0 = 0; i_0 < 16; i_0++) {\r\n      rtb_IC1 += rtConstP.Weights_Value_p[(i_0 << 4) + i] * rtb_Tanh[i_0];\r\n    }\r\n\r\n    rtb_Add_c[i] = rtb_IC1 + rtConstP.Bias_Value_b[i];\r\n  }\r\n\r\n  // End of Sum: '<S44>/Add'\r\n  // End of Outputs for SubSystem: '<S8>/fc4'\r\n\r\n  // Outputs for Atomic SubSystem: '<S8>/act4'\r\n  act1(rtb_Add_c, rtb_Tanh);\r\n\r\n  // End of Outputs for SubSystem: '<S8>/act4'\r\n  for (i = 0; i < 2; i++) {\r\n    // Update for Delay: '<S5>/Delay' incorporates:\r\n    //   Constant: '<S13>/Bias'\r\n    //   Constant: '<S13>/Weights'\r\n    //   Product: '<S13>/Matrix Multiply'\r\n    //   Sum: '<S28>/Add'\r\n    //   Sum: '<S5>/Add'\r\n    //   Trigonometry: '<S25>/Tanh'\r\n\r\n    rtb_IC1 = 0.0;\r\n    for (i_0 = 0; i_0 < 16; i_0++) {\r\n      // Outputs for Atomic SubSystem: '<S8>/dx'\r\n      rtb_IC1 += rtConstP.Weights_Value[(i_0 << 1) + i] * rtb_Tanh[i_0];\r\n\r\n      // End of Outputs for SubSystem: '<S8>/dx'\r\n    }\r\n\r\n    // Outputs for Atomic SubSystem: '<S8>/dx'\r\n    rtDW.Delay_DSTATE[i] += rtb_IC1 + rtConstP.Bias_Value[i];\r\n\r\n    // End of Update for Delay: '<S5>/Delay'\r\n    // End of Outputs for SubSystem: '<S8>/dx'\r\n\r\n    // Sum: '<S2>/Add' incorporates:\r\n    //   Constant: '<S2>/Constant'\r\n    //   Gain: '<S2>/Gain'\r\n\r\n    rtb_Delay[i] = static_cast<real32_T>(rtConstP.Gain_Gain[i] * rtb_Delay[i]) +\r\n      rtConstP.Constant_Value[i];\r\n  }\r\n\r\n  // End of Outputs for SubSystem: '<S1>/Neural State Space Model'\r\n  // End of Outputs for SubSystem: '<Root>/Neural State Space Battery Model'\r\n\r\n  // Outport: '<Root>/Out1'\r\n  rtY.Out1 = rtb_IC;\r\n\r\n  // Outport: '<Root>/Out2'\r\n  rtY.Out2 = rtb_Delay[0];\r\n\r\n  // Outport: '<Root>/Out3'\r\n  rtY.Out3 = rtb_Delay[1];\r\n}\r\n\r\n// Model initialize function\r\nvoid BatteryModel_NSS_CodeGeneration::initialize()\r\n{\r\n  // SystemInitialize for Atomic SubSystem: '<Root>/Neural State Space Battery Model' \r\n  // Start for InitialCondition: '<S1>/IC'\r\n  rtDW.IC_FirstOutputTime = true;\r\n\r\n  // Start for InitialCondition: '<S1>/IC1'\r\n  rtDW.IC1_FirstOutputTime = true;\r\n\r\n  // SystemInitialize for Atomic SubSystem: '<S1>/Neural State Space Model'\r\n  // InitializeConditions for Delay: '<S5>/Delay'\r\n  rtDW.Delay_DSTATE[0] = -1.0;\r\n  rtDW.Delay_DSTATE[1] = -0.5;\r\n\r\n  // End of SystemInitialize for SubSystem: '<S1>/Neural State Space Model'\r\n  // End of SystemInitialize for SubSystem: '<Root>/Neural State Space Battery Model' \r\n}\r\n\r\n// Constructor\r\nBatteryModel_NSS_CodeGeneration::BatteryModel_NSS_CodeGeneration():\r\n  rtU(),\r\n  rtY(),\r\n  rtDW()\r\n{\r\n  // Currently there is no constructor body generated.\r\n}\r\n\r\n// Destructor\r\n// Currently there is no destructor body generated.\r\nBatteryModel_NSS_CodeGeneration::~BatteryModel_NSS_CodeGeneration() = default;\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"BatteryModel_NSS_CodeGeneration.h","type":"header","group":"model","path":"C:\\Mahaveer\\Examples\\AI with MBD_ROM_ Hands on Workshop\\01-ROM of a Battery System\\Models\\BatteryModel_NSS_CodeGeneration_ert_rtw","tag":"","groupDisplay":"Model files","code":"//\r\n// File: BatteryModel_NSS_CodeGeneration.h\r\n//\r\n// Code generated for Simulink model 'BatteryModel_NSS_CodeGeneration'.\r\n//\r\n// Model version                  : 3.7\r\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n// C/C++ source code generated on : Tue Apr 29 12:04:26 2025\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: Intel->x86-32 (Windows32)\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n#ifndef BatteryModel_NSS_CodeGeneration_h_\r\n#define BatteryModel_NSS_CodeGeneration_h_\r\n#include <cmath>\r\n#include \"rtwtypes.h\"\r\n\r\n// Class declaration for model BatteryModel_NSS_CodeGeneration\r\nclass BatteryModel_NSS_CodeGeneration final\r\n{\r\n  // public data and function members\r\n public:\r\n  // Block signals and states (default storage) for system '<Root>'\r\n  struct DW {\r\n    real_T Delay_DSTATE[2];            // '<S5>/Delay'\r\n    boolean_T IC_FirstOutputTime;      // '<S1>/IC'\r\n    boolean_T IC1_FirstOutputTime;     // '<S1>/IC1'\r\n  };\r\n\r\n  // Constant parameters (default storage)\r\n  struct ConstP {\r\n    // Expression: Layer.Bias\r\n    //  Referenced by: '<S13>/Bias'\r\n\r\n    real_T Bias_Value[2];\r\n\r\n    // Expression: Layer.Weights\r\n    //  Referenced by: '<S13>/Weights'\r\n\r\n    real_T Weights_Value[32];\r\n\r\n    // Expression: Layer.Bias\r\n    //  Referenced by: '<S14>/Bias'\r\n\r\n    real_T Bias_Value_n[16];\r\n\r\n    // Expression: Layer.Weights\r\n    //  Referenced by: '<S14>/Weights'\r\n\r\n    real_T Weights_Value_l[80];\r\n\r\n    // Expression: Layer.Bias\r\n    //  Referenced by: '<S15>/Bias'\r\n\r\n    real_T Bias_Value_g[16];\r\n\r\n    // Expression: Layer.Weights\r\n    //  Referenced by: '<S15>/Weights'\r\n\r\n    real_T Weights_Value_f[256];\r\n\r\n    // Expression: Layer.Bias\r\n    //  Referenced by: '<S16>/Bias'\r\n\r\n    real_T Bias_Value_m[16];\r\n\r\n    // Expression: Layer.Weights\r\n    //  Referenced by: '<S16>/Weights'\r\n\r\n    real_T Weights_Value_i[256];\r\n\r\n    // Expression: Layer.Bias\r\n    //  Referenced by: '<S17>/Bias'\r\n\r\n    real_T Bias_Value_b[16];\r\n\r\n    // Expression: Layer.Weights\r\n    //  Referenced by: '<S17>/Weights'\r\n\r\n    real_T Weights_Value_p[256];\r\n\r\n    // Expression: NSSTrainingOutput.Normalization.Mu{1,4:5}\r\n    //  Referenced by: '<S2>/Constant'\r\n\r\n    real_T Constant_Value[2];\r\n\r\n    // Expression: NSSTrainingOutput.Normalization.Sigma{1,4:5}\r\n    //  Referenced by: '<S2>/Gain'\r\n\r\n    real_T Gain_Gain[2];\r\n  };\r\n\r\n  // External inputs (root inport signals with default storage)\r\n  struct ExtU {\r\n    real_T InputCurrent;               // '<Root>/InputCurrent'\r\n    real_T SOC;                        // '<Root>/SOC'\r\n    real_T Temperature;                // '<Root>/Temperature'\r\n  };\r\n\r\n  // External outputs (root outports fed by signals with default storage)\r\n  struct ExtY {\r\n    real_T Out1;                       // '<Root>/Out1'\r\n    real_T Out2;                       // '<Root>/Out2'\r\n    real_T Out3;                       // '<Root>/Out3'\r\n  };\r\n\r\n  // Copy Constructor\r\n  BatteryModel_NSS_CodeGeneration(BatteryModel_NSS_CodeGeneration const&) =\r\n    delete;\r\n\r\n  // Assignment Operator\r\n  BatteryModel_NSS_CodeGeneration& operator= (BatteryModel_NSS_CodeGeneration\r\n    const&) & = delete;\r\n\r\n  // Move Constructor\r\n  BatteryModel_NSS_CodeGeneration(BatteryModel_NSS_CodeGeneration &&) = delete;\r\n\r\n  // Move Assignment Operator\r\n  BatteryModel_NSS_CodeGeneration& operator= (BatteryModel_NSS_CodeGeneration &&)\r\n    = delete;\r\n\r\n  // External inputs\r\n  ExtU rtU;\r\n\r\n  // External outputs\r\n  ExtY rtY;\r\n\r\n  // model initialize function\r\n  void initialize();\r\n\r\n  // model step function\r\n  void step();\r\n\r\n  // Constructor\r\n  BatteryModel_NSS_CodeGeneration();\r\n\r\n  // Destructor\r\n  ~BatteryModel_NSS_CodeGeneration();\r\n\r\n  // private data and function members\r\n private:\r\n  // Block states\r\n  DW rtDW;\r\n\r\n  // private member function(s) for subsystem '<S8>/act1'\r\n  static void act1(const real_T rtu_In1[16], real_T rty_Out1[16]);\r\n};\r\n\r\n// Constant parameters (default storage)\r\nextern const BatteryModel_NSS_CodeGeneration::ConstP rtConstP;\r\n\r\n//-\r\n//  These blocks were eliminated from the model due to optimizations:\r\n//\r\n//  Block '<S2>/Reshape' : Reshape block reduction\r\n//  Block '<S6>/Reshape2' : Reshape block reduction\r\n//  Block '<S29>/Reshape' : Reshape block reduction\r\n//  Block '<S33>/Reshape' : Reshape block reduction\r\n//  Block '<S37>/Reshape' : Reshape block reduction\r\n//  Block '<S41>/Reshape' : Reshape block reduction\r\n//  Block '<S45>/Reshape' : Reshape block reduction\r\n//  Block '<S4>/Reshape' : Reshape block reduction\r\n\r\n\r\n//-\r\n//  The generated code includes comments that allow you to trace directly\r\n//  back to the appropriate location in the model.  The basic format\r\n//  is <system>/block_name, where system is the system number (uniquely\r\n//  assigned by Simulink) and block_name is the name of the block.\r\n//\r\n//  Use the MATLAB hilite_system command to trace the generated code back\r\n//  to the model.  For example,\r\n//\r\n//  hilite_system('<S3>')    - opens system 3\r\n//  hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\r\n//\r\n//  Here is the system hierarchy for this model\r\n//\r\n//  '<Root>' : 'BatteryModel_NSS_CodeGeneration'\r\n//  '<S1>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model'\r\n//  '<S2>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Denormalize'\r\n//  '<S3>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model'\r\n//  '<S4>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Normalize'\r\n//  '<S5>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS'\r\n//  '<S6>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network'\r\n//  '<S7>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network'\r\n//  '<S8>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem'\r\n//  '<S9>'   : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act1'\r\n//  '<S10>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act2'\r\n//  '<S11>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act3'\r\n//  '<S12>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act4'\r\n//  '<S13>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/dx'\r\n//  '<S14>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc1'\r\n//  '<S15>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc2'\r\n//  '<S16>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc3'\r\n//  '<S17>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc4'\r\n//  '<S18>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act1/Tanh_VSS'\r\n//  '<S19>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act1/Tanh_VSS/None'\r\n//  '<S20>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act2/Tanh_VSS'\r\n//  '<S21>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act2/Tanh_VSS/None'\r\n//  '<S22>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act3/Tanh_VSS'\r\n//  '<S23>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act3/Tanh_VSS/None'\r\n//  '<S24>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act4/Tanh_VSS'\r\n//  '<S25>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/act4/Tanh_VSS/None'\r\n//  '<S26>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/dx/BiasAddition'\r\n//  '<S27>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/dx/Reshape'\r\n//  '<S28>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/dx/BiasAddition/Add'\r\n//  '<S29>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/dx/Reshape/Reshape'\r\n//  '<S30>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc1/BiasAddition'\r\n//  '<S31>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc1/Reshape'\r\n//  '<S32>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc1/BiasAddition/Add'\r\n//  '<S33>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc1/Reshape/Reshape'\r\n//  '<S34>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc2/BiasAddition'\r\n//  '<S35>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc2/Reshape'\r\n//  '<S36>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc2/BiasAddition/Add'\r\n//  '<S37>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc2/Reshape/Reshape'\r\n//  '<S38>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc3/BiasAddition'\r\n//  '<S39>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc3/Reshape'\r\n//  '<S40>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc3/BiasAddition/Add'\r\n//  '<S41>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc3/Reshape/Reshape'\r\n//  '<S42>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc4/BiasAddition'\r\n//  '<S43>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc4/Reshape'\r\n//  '<S44>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc4/BiasAddition/Add'\r\n//  '<S45>'  : 'BatteryModel_NSS_CodeGeneration/Neural State Space Battery Model/Neural State Space Model/NSS/State Network/State Network/NetworkSubsystem/fc4/Reshape/Reshape'\r\n\r\n#endif                                 // BatteryModel_NSS_CodeGeneration_h_\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"BatteryModel_NSS_CodeGeneration_data.cpp","type":"source","group":"data","path":"C:\\Mahaveer\\Examples\\AI with MBD_ROM_ Hands on Workshop\\01-ROM of a Battery System\\Models\\BatteryModel_NSS_CodeGeneration_ert_rtw","tag":"","groupDisplay":"Data files","code":"//\r\n// File: BatteryModel_NSS_CodeGeneration_data.cpp\r\n//\r\n// Code generated for Simulink model 'BatteryModel_NSS_CodeGeneration'.\r\n//\r\n// Model version                  : 3.7\r\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n// C/C++ source code generated on : Tue Apr 29 12:04:26 2025\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: Intel->x86-32 (Windows32)\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n#include \"BatteryModel_NSS_CodeGeneration.h\"\r\n\r\n// Constant parameters (default storage)\r\nconst BatteryModel_NSS_CodeGeneration::ConstP rtConstP{\r\n  // Expression: Layer.Bias\r\n  //  Referenced by: '<S13>/Bias'\r\n\r\n  { -0.0022214353084564209, 0.0037971273995935917 },\r\n\r\n  // Expression: Layer.Weights\r\n  //  Referenced by: '<S13>/Weights'\r\n\r\n  { -0.067930065095424652, -0.17863591015338898, -0.49049940705299377,\r\n    0.48173418641090393, 0.090872034430503845, 0.48636427521705627,\r\n    0.32853889465332031, 0.3026888370513916, 0.08465036004781723,\r\n    0.18742206692695618, 0.52535504102706909, -0.53720903396606445,\r\n    -0.24959452450275421, -0.24380010366439819, -0.2579708993434906,\r\n    -0.0654163807630539, -0.40197432041168213, 0.55940908193588257,\r\n    -0.1140245720744133, -0.5307915210723877, 0.50592052936553955,\r\n    -0.23512920737266541, -0.41882872581481934, -0.4700295627117157,\r\n    0.044629465788602829, 0.019428383558988571, -0.35234346985816956,\r\n    -0.0757565051317215, 0.074572302401065826, 0.39017987251281738,\r\n    -0.29637748003005981, -0.14980420470237732 },\r\n\r\n  // Expression: Layer.Bias\r\n  //  Referenced by: '<S14>/Bias'\r\n\r\n  { -0.043884195387363434, 0.0736059918999672, 0.0024092043749988079,\r\n    0.045149657875299454, 0.14962771534919739, -0.2726781964302063,\r\n    0.20441627502441406, 0.038309022784233093, -0.002191316569224,\r\n    0.026933189481496811, 0.25701305270195007, -0.039935052394866943,\r\n    -0.0045686494559049606, -0.021055290475487709, 0.16831542551517487,\r\n    0.015852885320782661 },\r\n\r\n  // Expression: Layer.Weights\r\n  //  Referenced by: '<S14>/Weights'\r\n\r\n  { 0.25584912300109863, 0.36938017606735229, 0.40042826533317566,\r\n    0.4670310914516449, 0.0323423370718956, -0.20933325588703156,\r\n    0.31609681248664856, 0.40904349088668823, -0.19712963700294495,\r\n    -0.0971267968416214, -0.25810834765434265, 0.0028899011667817831,\r\n    0.39604401588439941, -0.39143401384353638, 0.0022538702469319105,\r\n    -0.20107798278331757, -0.45487880706787109, -0.064628876745700836,\r\n    -0.14334540069103241, 0.029367810115218163, -0.43969833850860596,\r\n    -0.35307776927948, 0.042704161256551743, 0.45733529329299927,\r\n    0.15730790793895721, 0.34949025511741638, 0.2982366681098938,\r\n    -0.077603481709957123, -0.38950726389884949, 0.45078709721565247,\r\n    0.11175879091024399, -0.14729280769824982, -0.17596030235290527,\r\n    0.16406078636646271, 0.38370099663734436, 0.43744972348213196,\r\n    0.65989816188812256, 0.11210591346025467, 0.040583718568086624,\r\n    -0.03578609973192215, 0.22064056992530823, -0.33075740933418274,\r\n    -0.11265591531991959, -0.30472195148468018, -0.21148549020290375,\r\n    -0.15417899191379547, 0.29700613021850586, 0.11617454141378403,\r\n    0.0336710587143898, 0.38489741086959839, -0.032965250313282013,\r\n    0.1074531227350235, 0.24498212337493896, -0.17688468098640442,\r\n    -0.16881722211837769, 0.2375769317150116, -0.014802271500229836,\r\n    0.17015086114406586, 0.36238551139831543, -0.17309775948524475,\r\n    -0.1941579133272171, 0.18413166701793671, -0.46425867080688477,\r\n    -0.34834176301956177, 0.30467915534973145, -0.4232822060585022,\r\n    0.14709654450416565, -0.31193813681602478, -0.1554524153470993,\r\n    0.06945984810590744, -0.21291284263134003, 0.16491910815238953,\r\n    -0.17642152309417725, -0.42300847172737122, 0.30422517657279968,\r\n    -0.43593844771385193, -0.27201166749000549, -0.14918038249015808,\r\n    0.024288330227136612, -0.37409400939941406 },\r\n\r\n  // Expression: Layer.Bias\r\n  //  Referenced by: '<S15>/Bias'\r\n\r\n  { 0.042552798986434937, -0.012469880282878876, -0.00701942527666688,\r\n    -0.014110749587416649, -0.017847361043095589, 0.07934841513633728,\r\n    -0.011591370217502117, 0.028935136273503304, -0.19003766775131226,\r\n    -0.0025761579163372517, -0.056418750435113907, 0.037615898996591568,\r\n    -0.00438616843894124, 0.030424892902374268, 0.14901876449584961,\r\n    0.023809986189007759 },\r\n\r\n  // Expression: Layer.Weights\r\n  //  Referenced by: '<S15>/Weights'\r\n\r\n  { 0.2327471524477005, 0.025998378172516823, -0.24030208587646484,\r\n    0.32530155777931213, -0.2999972403049469, 0.41870015859603882,\r\n    0.25155135989189148, 0.034120537340641022, -0.044342756271362305,\r\n    -0.17887011170387268, 0.38478919863700867, -0.17221644520759583,\r\n    -0.029676802456378937, 0.000843824993353337, 0.30931156873703003,\r\n    -0.042194243520498276, 0.31266516447067261, -0.29517063498497009,\r\n    0.36069560050964355, 0.10440592467784882, -0.062175791710615158,\r\n    -0.20789593458175659, -0.38155433535575867, -0.0918804481625557,\r\n    -0.47515144944190979, -0.013489902950823307, -0.38217803835868835,\r\n    0.25389567017555237, 0.39758226275444031, -0.31561854481697083,\r\n    0.25346964597702026, -0.31115230917930603, -0.018471525982022285,\r\n    -0.30972400307655334, 0.11732566356658936, -0.25452929735183716,\r\n    -0.35261103510856628, 0.064263187348842621, -0.28326037526130676,\r\n    -0.079784691333770752, -0.28755766153335571, -0.41525489091873169,\r\n    0.23500560224056244, 0.32253092527389526, -0.032693348824977875,\r\n    -0.14969968795776367, -0.052688684314489365, -0.14458155632019043,\r\n    0.23703929781913757, 0.40542224049568176, -0.21473629772663116,\r\n    0.0650692954659462, -0.0604252815246582, -0.0043084411881864071,\r\n    0.31828644871711731, 0.075369350612163544, -0.2857850193977356,\r\n    0.14336912333965302, -0.11313486099243164, -0.10106504708528519,\r\n    0.36008617281913757, -0.36240395903587341, -0.34567543864250183,\r\n    0.0087606543675065041, 0.328529953956604, 0.24390420317649841,\r\n    -0.14839676022529602, -0.30420204997062683, 0.42287811636924744,\r\n    0.4661218523979187, 0.18245193362236023, -0.13925042748451233,\r\n    0.23261390626430511, -0.16261990368366241, 0.21606460213661194,\r\n    -0.13199962675571442, -0.35782539844512939, 0.29638561606407166,\r\n    0.37818378210067749, 0.46220439672470093, 0.089515373110771179,\r\n    0.44898006319999695, 0.063843607902526855, -0.04533093050122261,\r\n    -0.15548650920391083, 0.35501393675804138, 0.38936835527420044,\r\n    0.3897193968296051, -0.33891597390174866, -0.2222139984369278,\r\n    0.35709697008132935, 0.092424161732196808, 0.058932751417160034,\r\n    0.10915382951498032, 0.4653221070766449, 0.29658499360084534,\r\n    0.42050957679748535, 0.01055150106549263, -0.17989899218082428,\r\n    -0.099787533283233643, -0.18383543193340302, -0.4104841947555542,\r\n    0.23066192865371704, 0.075119622051715851, -0.17550477385520935,\r\n    -0.1151316910982132, 0.29975947737693787, 0.12008064240217209,\r\n    0.33750051259994507, 0.27428212761878967, 0.23164168000221252,\r\n    0.18324194848537445, 0.31032624840736389, 0.070392303168773651,\r\n    0.13351109623908997, -0.41184866428375244, 0.039760854095220566,\r\n    0.18570576608181, -0.045406438410282135, -0.10031452029943466,\r\n    -0.26501235365867615, 0.33231824636459351, -0.029554609209299088,\r\n    0.33196377754211426, 0.013346575200557709, -0.094999179244041443,\r\n    -0.42277178168296814, -0.19268016517162323, 0.27995210886001587,\r\n    -0.2792019248008728, 0.12730418145656586, 0.12115287035703659,\r\n    -0.38133683800697327, 0.22949454188346863, 0.38440927863121033,\r\n    0.20540343225002289, -0.24204349517822266, -0.297278493642807,\r\n    0.36615210771560669, -0.18403826653957367, -0.28266096115112305,\r\n    -0.031072027981281281, 0.31206139922142029, -0.29298621416091919,\r\n    0.2115509957075119, 0.20245459675788879, -0.18341858685016632,\r\n    -0.22448386251926422, 0.3619474470615387, -0.26108163595199585,\r\n    -0.13015243411064148, 0.12652388215065002, -0.0762888565659523,\r\n    0.13329672813415527, 0.4412701427936554, 0.16641323268413544,\r\n    0.14311541616916656, -0.18978415429592133, 0.25849679112434387,\r\n    0.20810918509960175, -0.30201631784439087, -0.22360336780548096,\r\n    0.07743237167596817, 0.02207314595580101, 0.37527400255203247,\r\n    0.25391682982444763, -0.23818628489971161, -0.324710488319397,\r\n    0.26722243428230286, 0.17575521767139435, 0.3720288872718811,\r\n    -0.092605426907539368, -0.2154182493686676, 0.19632817804813385,\r\n    -0.099853560328483582, 0.02011696994304657, -0.2498587965965271,\r\n    0.37531068921089172, 0.031466711312532425, -0.35338589549064636,\r\n    0.0037057942245155573, -0.23392465710639954, 0.27291864156723022,\r\n    0.30447298288345337, 0.11499103158712387, -0.15354706346988678,\r\n    0.47589877247810364, 0.19660736620426178, -0.30719324946403503,\r\n    -0.16687896847724915, 0.12290683388710022, -0.00023273041006177664,\r\n    -0.40757843852043152, 0.064945124089717865, 0.37654393911361694,\r\n    0.20028457045555115, 0.44092193245887756, 0.29902383685112,\r\n    0.090846531093120575, 0.18432138860225677, 0.2871917188167572,\r\n    0.17928610742092133, -0.29570016264915466, -0.32048910856246948,\r\n    -0.13644029200077057, 0.26212731003761292, -0.39935055375099182,\r\n    -0.20317786931991577, -0.38130611181259155, 0.13026349246501923,\r\n    0.32010757923126221, 0.20862315595149994, 0.030697399750351906,\r\n    -0.19559240341186523, 0.33518141508102417, 0.2728467583656311,\r\n    0.39996886253356934, 0.31410679221153259, 0.25448828935623169,\r\n    0.11333661526441574, 0.20134103298187256, -0.14720740914344788,\r\n    0.13075456023216248, 0.30895417928695679, -0.35936340689659119,\r\n    -0.21404761075973511, -0.21637016534805298, -0.42281249165534973,\r\n    -0.066925264894962311, -0.37437012791633606, 0.28707113862037659,\r\n    -0.021466054022312164, 0.036234032362699509, 0.35500261187553406,\r\n    0.26423069834709167, 0.099474847316741943, -0.18417452275753021,\r\n    0.35271388292312622, -0.3647981584072113, -0.29610484838485718,\r\n    -0.14390556514263153, 0.14723993837833405, 0.063484020531177521,\r\n    0.0066646602936089039, -0.25246623158454895, -0.22813859581947327,\r\n    -0.29235374927520752, -0.36271792650222778, 0.28365159034729004,\r\n    0.30034032464027405, 0.1772344708442688, -0.19295202195644379,\r\n    0.044276390224695206, -0.11489475518465042, -0.071439661085605621,\r\n    -0.31184503436088562 },\r\n\r\n  // Expression: Layer.Bias\r\n  //  Referenced by: '<S16>/Bias'\r\n\r\n  { -0.026480183005332947, -0.016090750694274902, -0.028029512614011765,\r\n    -0.06556151807308197, -0.0070230308920145035, -0.023460309952497482,\r\n    0.033199761062860489, 0.019281286746263504, 0.026644805446267128,\r\n    -0.000480759801575914, -0.021881747990846634, -0.0012730193557217717,\r\n    -0.016066733747720718, 0.00971317384392023, -0.02904956229031086,\r\n    0.01325588021427393 },\r\n\r\n  // Expression: Layer.Weights\r\n  //  Referenced by: '<S16>/Weights'\r\n\r\n  { -0.2185034453868866, -0.38438957929611206, -0.082336850464344025,\r\n    -0.072292082011699677, -0.1736314445734024, 0.30799731612205505,\r\n    -0.24925863742828369, -0.30642926692962646, 0.32234930992126465,\r\n    0.30915582180023193, -0.31405654549598694, 0.052960094064474106,\r\n    0.075719401240348816, 0.16667449474334717, 0.11414685100317001,\r\n    0.02708987332880497, 0.29077225923538208, -0.39558839797973633,\r\n    -0.22321714460849762, 0.064271010458469391, 0.19786696135997772,\r\n    -0.010445761494338512, 0.3602130115032196, 0.38710218667984009,\r\n    0.2587505578994751, 0.23605760931968689, -0.2816760241985321,\r\n    0.28077787160873413, -0.37355738878250122, 0.083007171750068665,\r\n    -0.12208943068981171, -0.37555861473083496, -0.26322144269943237,\r\n    0.036723200231790543, 0.296588659286499, 0.13359025120735168,\r\n    0.37971755862236023, 0.19920341670513153, -0.17140641808509827,\r\n    -0.16082191467285156, 0.28235328197479248, -0.059274725615978241,\r\n    -0.37647727131843567, -0.408944308757782, 0.21623905003070831,\r\n    0.33710765838623047, 0.30635234713554382, -0.075809121131896973,\r\n    -0.14455927908420563, -0.13225468993186951, 0.14535945653915405,\r\n    0.21321302652359009, 0.38661733269691467, 0.26854926347732544,\r\n    -0.050577744841575623, 0.018582401797175407, -0.16283977031707764,\r\n    -0.058496896177530289, 0.25249829888343811, 0.19678543508052826,\r\n    0.282025545835495, 0.40754887461662292, -0.094219520688056946,\r\n    0.084425546228885651, 0.32663476467132568, 0.18206034600734711,\r\n    0.22283335030078888, 0.020942941308021545, -0.36371603608131409,\r\n    0.044727001339197159, -0.2626778781414032, 0.0055187256075441837,\r\n    0.39080500602722168, -0.31919071078300476, 0.37104353308677673,\r\n    0.31997391581535339, -0.387503057718277, 0.26428064703941345,\r\n    -0.22421492636203766, -0.39361405372619629, -0.10525573045015335,\r\n    0.11099985986948013, -0.048258211463689804, -0.059348024427890778,\r\n    0.40149679780006409, 0.22641941905021667, 0.37544023990631104,\r\n    -0.027546629309654236, -0.041135545819997787, -0.34730812907218933,\r\n    -0.40197861194610596, 0.026425179094076157, 0.39468613266944885,\r\n    -0.010508901439607143, -0.15046879649162292, -0.22219949960708618,\r\n    0.32274559140205383, -0.096849329769611359, 0.29666021466255188,\r\n    0.3790431022644043, -0.11402681469917297, -0.23859737813472748,\r\n    -0.019539507105946541, 0.044212505221366882, 0.092345729470252991,\r\n    -0.28637716174125671, 0.10172738134860992, -0.046834196895360947,\r\n    -0.23870649933815002, 0.37120336294174194, -0.32598039507865906,\r\n    -0.17540735006332397, 0.37600475549697876, 0.16233794391155243,\r\n    -0.070726111531257629, 0.019924812018871307, -0.11994128674268723,\r\n    0.15325683355331421, 0.27731335163116455, -0.11113789677619934,\r\n    0.24243773519992828, 0.10043884068727493, -0.25912508368492126,\r\n    -0.15440233051776886, -0.16609899699687958, -0.2649233341217041,\r\n    -0.057172060012817383, 0.032721437513828278, 0.28521034121513367,\r\n    -0.42424345016479492, 0.12628050148487091, -0.22511440515518188,\r\n    0.26183801889419556, 0.13772724568843842, -0.31138545274734497,\r\n    -0.24693302810192108, 0.4298568069934845, 0.24538493156433105,\r\n    0.33075699210166931, -0.14165948331356049, 0.14807392656803131,\r\n    -0.084797769784927368, 0.11832481622695923, 0.15560697019100189,\r\n    0.36286532878875732, 0.0655527114868164, -0.049368411302566528,\r\n    -0.29240432381629944, -0.0122144790366292, 0.23599067330360413,\r\n    -0.1178058534860611, 0.049537528306245804, -0.32465231418609619,\r\n    -0.28463038802146912, 0.46192449331283569, 0.11540675908327103,\r\n    0.078869462013244629, 0.27913308143615723, -0.27684199810028076,\r\n    0.1913793534040451, -0.39634612202644348, -0.36718559265136719,\r\n    0.25793272256851196, 0.35748490691185, 0.43673363327980042,\r\n    0.31506088376045227, -0.34200042486190796, -0.3249146044254303,\r\n    0.28561758995056152, 0.034839142113924026, 0.26685613393783569,\r\n    0.081582881510257721, 0.21679934859275818, 0.35958781838417053,\r\n    0.12880553305149078, 0.21725107729434967, -0.1895260363817215,\r\n    -0.34479019045829773, 0.20530353486537933, 0.24324324727058411,\r\n    0.21170991659164429, -0.2591717541217804, 0.36064687371253967,\r\n    -0.0074874740093946457, 0.054857973009347916, 0.1134912520647049,\r\n    0.15343901515007019, -0.3601861298084259, 0.39232870936393738,\r\n    -0.37079983949661255, -0.12960848212242126, -0.052615180611610413,\r\n    0.27898067235946655, -0.26083120703697205, -0.303117573261261,\r\n    0.43213975429534912, -0.11001221835613251, -0.33821752667427063,\r\n    0.19571708142757416, 0.3302074670791626, 0.22020728886127472,\r\n    0.38146033883094788, 0.13719187676906586, 0.072419688105583191,\r\n    -0.05986338108778, -0.015321246348321438, -0.031848117709159851,\r\n    0.094313696026802063, 0.21259875595569611, -0.005303630605340004,\r\n    -0.13648833334445953, -0.11459928750991821, -0.15934561192989349,\r\n    -0.16927638649940491, -0.030620338395237923, -0.32522320747375488,\r\n    -0.31550112366676331, 0.28869134187698364, 0.059189949184656143,\r\n    -0.31784075498580933, 0.12978182733058929, -0.00023444970429409295,\r\n    0.31171515583992004, 0.35214844346046448, -0.17265476286411285,\r\n    0.33869364857673645, 0.10501012951135635, -0.32396897673606873,\r\n    -0.11666340380907059, -0.074670024216175079, 0.41968470811843872,\r\n    0.23341326415538788, 0.035134807229042053, 0.10716221481561661,\r\n    -0.35155478119850159, 0.12833122909069061, -0.38121870160102844,\r\n    0.050611980259418488, 0.46433323621749878, -0.2335544228553772,\r\n    -0.16028942167758942, 0.3904246985912323, -0.0085303317755460739,\r\n    -0.19220490753650665, 0.0731947049498558, -0.13633495569229126,\r\n    -0.38389331102371216, 0.33486008644104004, -0.2141566127538681,\r\n    -0.40983659029006958, -0.30822813510894775, -0.23002156615257263,\r\n    -0.097022764384746552, 0.3784177303314209, -0.3550260066986084,\r\n    -0.12794458866119385 },\r\n\r\n  // Expression: Layer.Bias\r\n  //  Referenced by: '<S17>/Bias'\r\n\r\n  { -0.084032662212848663, 0.01216516550630331, 0.0031493185088038445,\r\n    -0.021663561463356018, 0.013412350788712502, 0.0073733078315854073,\r\n    -0.0045140436850488186, -0.0080271046608686447, 0.016844134777784348,\r\n    -0.0056818514131009579, -0.0083993514999747276, 0.00686428789049387,\r\n    -0.0030828411690890789, -1.7416026821592823E-5, 0.016956571489572525,\r\n    0.0035273074172437191 },\r\n\r\n  // Expression: Layer.Weights\r\n  //  Referenced by: '<S17>/Weights'\r\n\r\n  { -0.23984313011169434, -0.45671236515045166, 0.27287152409553528,\r\n    0.3713260293006897, 0.030049145221710205, -0.060118190944194794,\r\n    0.32265603542327881, 0.073896683752536774, -0.082930266857147217,\r\n    0.38741466403007507, -0.22215794026851654, 0.24041761457920074,\r\n    0.31688326597213745, 0.20056779682636261, 0.21727898716926575,\r\n    0.048425283282995224, 0.36754468083381653, -0.3934607207775116,\r\n    -0.26402080059051514, 0.26965343952178955, 0.042651209980249405,\r\n    0.00092863210011273623, 0.20309002697467804, 0.06431087851524353,\r\n    0.11251428723335266, -0.28925079107284546, -0.27584367990493774,\r\n    -0.24991261959075928, 0.26743093132972717, 0.064448922872543335,\r\n    -0.052839025855064392, -0.11785179376602173, -0.2377554178237915,\r\n    0.34967443346977234, 0.35964936017990112, -0.01141075324267149,\r\n    0.060803115367889404, 0.12569843232631683, -0.17531973123550415,\r\n    0.34095120429992676, -0.43209052085876465, -0.26100260019302368,\r\n    0.050242803990840912, -0.30540892481803894, -0.4209555983543396,\r\n    -0.16223648190498352, 0.33284595608711243, 0.18161073327064514,\r\n    0.13728928565979004, -0.35985344648361206, -0.22706744074821472,\r\n    -0.094377227127552032, -0.045323260128498077, -0.34405156970024109,\r\n    0.17135509848594666, 0.28473383188247681, 0.16899873316287994,\r\n    0.20265188813209534, 0.21471144258975983, -0.47345396876335144,\r\n    0.081102177500724792, 0.16167593002319336, -0.42799794673919678,\r\n    -0.00818438921123743, 0.23166303336620331, -0.33569157123565674,\r\n    -0.07071993499994278, -0.041294272989034653, 0.26893830299377441,\r\n    0.33383429050445557, 0.077620759606361389, 0.031115356832742691,\r\n    0.052722800523042679, 0.34568774700164795, -0.4208928644657135,\r\n    -0.21166469156742096, 0.26557627320289612, 0.24495129287242889,\r\n    0.21343100070953369, 0.23964786529541016, -0.1217888668179512,\r\n    -0.41555643081665039, 0.35181039571762085, -0.35106626152992249,\r\n    0.388537734746933, -0.12393056601285934, -0.2982754111289978,\r\n    -0.13674497604370117, 0.059014417231082916, -0.062871433794498444,\r\n    0.074026748538017273, -0.031699210405349731, 0.10527709871530533,\r\n    0.31433960795402527, 0.055956102907657623, 0.38365694880485535,\r\n    -0.12037243694067001, -0.13300065696239471, 0.018745604902505875,\r\n    0.21594177186489105, 0.0941089391708374, 0.15133149921894073,\r\n    -0.3008747398853302, 0.43059825897216797, 0.30308479070663452,\r\n    -0.41669261455535889, -0.37912383675575256, -0.33767718076705933,\r\n    -0.14146140217781067, -0.28076642751693726, -0.36598315834999084,\r\n    0.42213162779808044, 0.22426782548427582, 0.15700666606426239,\r\n    -0.25551417469978333, 0.20749877393245697, 0.22578881680965424,\r\n    -0.26179090142250061, -0.11375786364078522, -0.13524852693080902,\r\n    0.22569827735424042, -0.096634753048419952, 0.074306510388851166,\r\n    -0.072058327496051788, 0.37659582495689392, 0.14507292211055756,\r\n    0.18961432576179504, -0.32863715291023254, 0.35779872536659241,\r\n    -0.16119061410427094, 0.019103977829217911, -0.417701780796051,\r\n    -0.2457641214132309, -0.12370540201663971, -0.37753435969352722,\r\n    -0.048587962985038757, 0.04375937208533287, 0.42136156558990479,\r\n    -0.35241362452507019, -0.39739412069320679, -0.25060731172561646,\r\n    -0.37649551033973694, -0.017367126420140266, -0.223613440990448,\r\n    0.41224730014801025, 0.12282497435808182, 0.0011367077240720391,\r\n    0.21918772161006927, -0.11003021150827408, 0.10221731662750244,\r\n    -0.32592958211898804, -0.29536330699920654, -0.25174173712730408,\r\n    -0.19309361279010773, 0.25481203198432922, 0.18850758671760559,\r\n    0.40871331095695496, 0.23059436678886414, -0.36851403117179871,\r\n    0.41865554451942444, 0.42094328999519348, -0.40450349450111389,\r\n    -0.35340535640716553, -0.078922398388385773, -0.33424606919288635,\r\n    0.045555848628282547, 0.14255008101463318, 0.062176559120416641,\r\n    -0.38853850960731506, -0.0789887011051178, -0.30196636915206909,\r\n    0.20999136567115784, 0.40338721871376038, 0.071192160248756409,\r\n    -0.21825145184993744, 0.25471866130828857, 0.40707796812057495,\r\n    -0.39629647135734558, 0.19366936385631561, 0.329557329416275,\r\n    -0.34429085254669189, -0.0064438306726515293, 0.10047487914562225,\r\n    -0.39985612034797668, 0.35989385843276978, -0.33021065592765808,\r\n    0.20493869483470917, 0.17125827074050903, -0.00092213315656408668,\r\n    0.011060291901230812, 0.36570477485656738, 0.352125346660614,\r\n    -0.43470004200935364, -0.16289831697940826, 0.44670796394348145,\r\n    -0.12680837512016296, -0.31863492727279663, -0.14050322771072388,\r\n    -0.14660072326660156, 0.12418265640735626, -0.054463207721710205,\r\n    0.043414436280727386, -0.037896513938903809, 0.16474750638008118,\r\n    0.39016842842102051, -0.15504388511180878, 0.059040553867816925,\r\n    0.15284605324268341, 0.30114975571632385, 0.16191045939922333,\r\n    0.21998974680900574, 0.29517561197280884, -0.21799400448799133,\r\n    -0.25324872136116028, -0.15531119704246521, 0.34621462225914,\r\n    -0.12568454444408417, 0.022897033020853996, -0.051966961473226547,\r\n    -0.20387841761112213, 0.17474676668643951, 0.17618006467819214,\r\n    -0.045052524656057358, -0.13811038434505463, 0.264900803565979,\r\n    -0.23258903622627258, -0.076775133609771729, 0.028643004596233368,\r\n    -0.27844220399856567, -0.085639022290706635, 0.2898731529712677,\r\n    0.32709813117980957, 0.2219432145357132, -0.16217617690563202,\r\n    -0.022668838500976562, -0.071136638522148132, 0.45112234354019165,\r\n    0.018217511475086212, -0.13698017597198486, 0.24380606412887573,\r\n    -0.014465814456343651, 0.19356413185596466, -0.26867961883544922,\r\n    0.12369383871555328, 0.092684470117092133, 0.10166697204113007,\r\n    -0.10895637422800064, -0.33855906128883362, -0.25143229961395264,\r\n    0.4186728298664093, -0.2446424663066864, -0.32546338438987732,\r\n    0.26325735449790955, -0.31360915303230286, 0.13310480117797852,\r\n    0.22671227157115936 },\r\n\r\n  // Expression: NSSTrainingOutput.Normalization.Mu{1,4:5}\r\n  //  Referenced by: '<S2>/Constant'\r\n\r\n  { 287.59591868026467, 37.633588307837606 },\r\n\r\n  // Expression: NSSTrainingOutput.Normalization.Sigma{1,4:5}\r\n  //  Referenced by: '<S2>/Gain'\r\n\r\n  { 6.5486846322788379, 2.3248828363945289 }\r\n};\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"C:\\Mahaveer\\Examples\\AI with MBD_ROM_ Hands on Workshop\\01-ROM of a Battery System\\Models\\BatteryModel_NSS_CodeGeneration_ert_rtw","tag":"","groupDisplay":"Utility files","code":"//\r\n// File: rtwtypes.h\r\n//\r\n// Code generated for Simulink model 'BatteryModel_NSS_CodeGeneration'.\r\n//\r\n// Model version                  : 3.7\r\n// Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\r\n// C/C++ source code generated on : Tue Apr 29 12:04:26 2025\r\n//\r\n// Target selection: ert.tlc\r\n// Embedded hardware selection: Intel->x86-32 (Windows32)\r\n// Code generation objectives:\r\n//    1. Execution efficiency\r\n//    2. RAM efficiency\r\n// Validation result: Not run\r\n//\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n// Logical type definitions\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n//=======================================================================*\r\n//  Target hardware information\r\n//    Device type: Intel->x86-32 (Windows32)\r\n//    Number of bits:     char:   8    short:   16    int:  32\r\n//                        long:  32    long long:  64\r\n//                        native word size:  32\r\n//    Byte ordering: LittleEndian\r\n//    Signed integer division rounds to: Zero\r\n//    Shift right on a signed integer as arithmetic shift: on\r\n// =======================================================================\r\n\r\n//=======================================================================*\r\n//  Fixed width word size data types:                                     *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n//    real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n// =======================================================================\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef short int16_T;\r\ntypedef unsigned short uint16_T;\r\ntypedef int int32_T;\r\ntypedef unsigned int uint32_T;\r\ntypedef long long int64_T;\r\ntypedef unsigned long long uint64_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n//===========================================================================*\r\n//  Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n//                            real_T, time_T, ulong_T, ulonglong_T.           *\r\n// ===========================================================================\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef unsigned long long ulonglong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n//=======================================================================*\r\n//  Min and Max:                                                          *\r\n//    int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n//    uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n// =======================================================================\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n\r\n// Block D-Work pointer type\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 // RTWTYPES_H\r\n\r\n//\r\n// File trailer for generated code.\r\n//\r\n// [EOF]\r\n//\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};